-- File generated by the BNF Converter (bnfc 2.9.5).

{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language Parser.

module Parser.Abs where

import Prelude (Char, Double, Integer, String)
import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Functor, Foldable, Traversable
  , Int, Maybe(..)
  )
import qualified Data.String

type Block = Block' BNFC'Position
data Block' a = Blck a [Instruction' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Instruction = Instruction' BNFC'Position
data Instruction' a
    = Stmt a (Statement' a) | Decl a (Declaration' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Declaration = Declaration' BNFC'Position
data Declaration' a
    = ConstDecl a Ident (Expr' a)
    | VarDecl a Ident (Type' a) (Expr' a)
    | FunDecl a Ident [Parameter' a] (Type' a) (Block' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Parameter = Parameter' BNFC'Position
data Parameter' a = Param a (Modality' a) Ident (Type' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Modality = Modality' BNFC'Position
data Modality' a
    = Modality1 a
    | Modality_val a
    | Modality_ref a
    | Modality_valres a
    | Modality_res a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Type = Type' BNFC'Position
data Type' a
    = BsType a (BasicType' a)
    | ArrayType a (Expr' a) (Type' a)
    | CArrType a (Expr' a) (Type' a)
    | UnsizedArrayType a (Type' a)
    | UnsizedCArrayType a (Type' a)
    | Pointer a (Type' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type BasicType = BasicType' BNFC'Position
data BasicType' a
    = BasicType_bool a
    | BasicType_char a
    | BasicType_int a
    | BasicType_string a
    | BasicType_float a
    | BasicType_void a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Statement = Statement' BNFC'Position
data Statement' a
    = Compound a (Block' a)
    | Jump a (JumpStatement' a)
    | Iter a (IterStatement' a)
    | Branch a (BranchStatement' a)
    | Assign a (Expr' a) (Assignment_op' a) (Expr' a)
    | TryStmt a (Block' a) (Block' a)
    | Throw a String
    | StmntExpr a (Expr' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Assignment_op = Assignment_op' BNFC'Position
data Assignment_op' a
    = AssignOp a
    | AssignMul a
    | AssignAdd a
    | AssignDiv a
    | AssignSub a
    | AssignPow a
    | AssignAnd a
    | AssignOr a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type JumpStatement = JumpStatement' BNFC'Position
data JumpStatement' a
    = Break a | Continue a | RetExpVoid a | RetExp a (Expr' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type BranchStatement = BranchStatement' BNFC'Position
data BranchStatement' a
    = If a (Expr' a) (Block' a)
    | IfElse a (Expr' a) (Block' a) (Block' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type IterStatement = IterStatement' BNFC'Position
data IterStatement' a
    = While a (Expr' a) (Block' a)
    | DoWhile a (Block' a) (Expr' a)
    | For a Ident (Expr' a) (Expr' a) (Expr' a) (Block' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Expr = Expr' BNFC'Position
data Expr' a
    = IfExpr a (Expr' a) (Expr' a) (Expr' a)
    | Or a (Expr' a) (Expr' a)
    | And a (Expr' a) (Expr' a)
    | Not a (Expr' a)
    | Eq a (Expr' a) (Expr' a)
    | Neq a (Expr' a) (Expr' a)
    | Lt a (Expr' a) (Expr' a)
    | LtE a (Expr' a) (Expr' a)
    | Gt a (Expr' a) (Expr' a)
    | GtE a (Expr' a) (Expr' a)
    | Add a (Expr' a) (Expr' a)
    | Sub a (Expr' a) (Expr' a)
    | Mul a (Expr' a) (Expr' a)
    | Div a (Expr' a) (Expr' a)
    | Mod a (Expr' a) (Expr' a)
    | Pow a (Expr' a) (Expr' a)
    | Neg a (Expr' a)
    | PreInc a (Expr' a)
    | PreDecr a (Expr' a)
    | PostInc a (Expr' a)
    | PostDecr a (Expr' a)
    | Ref a (Expr' a)
    | Deref a (Expr' a)
    | ArrayAcc a (Expr' a) (Expr' a)
    | Id a Ident
    | FunCall a Ident [Expr' a]
    | Int a Integer
    | Char a Char
    | String a String
    | Float a Double
    | Bool a (Boolean' a)
    | Array a [Expr' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Boolean = Boolean' BNFC'Position
data Boolean' a = Boolean_True a | Boolean_False a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

newtype Ident = Ident String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition Block where
  hasPosition = \case
    Blck p _ -> p

instance HasPosition Instruction where
  hasPosition = \case
    Stmt p _ -> p
    Decl p _ -> p

instance HasPosition Declaration where
  hasPosition = \case
    ConstDecl p _ _ -> p
    VarDecl p _ _ _ -> p
    FunDecl p _ _ _ _ -> p

instance HasPosition Parameter where
  hasPosition = \case
    Param p _ _ _ -> p

instance HasPosition Modality where
  hasPosition = \case
    Modality1 p -> p
    Modality_val p -> p
    Modality_ref p -> p
    Modality_valres p -> p
    Modality_res p -> p

instance HasPosition Type where
  hasPosition = \case
    BsType p _ -> p
    ArrayType p _ _ -> p
    CArrType p _ _ -> p
    UnsizedArrayType p _ -> p
    UnsizedCArrayType p _ -> p
    Pointer p _ -> p

instance HasPosition BasicType where
  hasPosition = \case
    BasicType_bool p -> p
    BasicType_char p -> p
    BasicType_int p -> p
    BasicType_string p -> p
    BasicType_float p -> p
    BasicType_void p -> p

instance HasPosition Statement where
  hasPosition = \case
    Compound p _ -> p
    Jump p _ -> p
    Iter p _ -> p
    Branch p _ -> p
    Assign p _ _ _ -> p
    TryStmt p _ _ -> p
    Throw p _ -> p
    StmntExpr p _ -> p

instance HasPosition Assignment_op where
  hasPosition = \case
    AssignOp p -> p
    AssignMul p -> p
    AssignAdd p -> p
    AssignDiv p -> p
    AssignSub p -> p
    AssignPow p -> p
    AssignAnd p -> p
    AssignOr p -> p

instance HasPosition JumpStatement where
  hasPosition = \case
    Break p -> p
    Continue p -> p
    RetExpVoid p -> p
    RetExp p _ -> p

instance HasPosition BranchStatement where
  hasPosition = \case
    If p _ _ -> p
    IfElse p _ _ _ -> p

instance HasPosition IterStatement where
  hasPosition = \case
    While p _ _ -> p
    DoWhile p _ _ -> p
    For p _ _ _ _ _ -> p

instance HasPosition Expr where
  hasPosition = \case
    IfExpr p _ _ _ -> p
    Or p _ _ -> p
    And p _ _ -> p
    Not p _ -> p
    Eq p _ _ -> p
    Neq p _ _ -> p
    Lt p _ _ -> p
    LtE p _ _ -> p
    Gt p _ _ -> p
    GtE p _ _ -> p
    Add p _ _ -> p
    Sub p _ _ -> p
    Mul p _ _ -> p
    Div p _ _ -> p
    Mod p _ _ -> p
    Pow p _ _ -> p
    Neg p _ -> p
    PreInc p _ -> p
    PreDecr p _ -> p
    PostInc p _ -> p
    PostDecr p _ -> p
    Ref p _ -> p
    Deref p _ -> p
    ArrayAcc p _ _ -> p
    Id p _ -> p
    FunCall p _ _ -> p
    Int p _ -> p
    Char p _ -> p
    String p _ -> p
    Float p _ -> p
    Bool p _ -> p
    Array p _ -> p

instance HasPosition Boolean where
  hasPosition = \case
    Boolean_True p -> p
    Boolean_False p -> p

